#include "MultiGraph.h"
#include "Exceptions.h"
#include "IntPair.h"
#include <iostream>
#include <iomanip>
#include <fstream>

//=======================//
// Implemented Functions //
//=======================//
MultiGraph::MultiGraph()
{}

MultiGraph::MultiGraph(const std::string& filePath)
{
    // ============================= //
    // This function is implemented  //
    // Do not edit this function !   //
    // ============================= //
    // Tokens
    std::string tokens[5];
    std::ifstream mapFile(filePath.c_str());

    if(!mapFile.is_open())
    {
        std::cout << "Unable to open " << filePath << std::endl;
        return;
    }

    // Read line by line
    std::string line;
    while (std::getline(mapFile, line))
    {
        // Empty Line Skip
        if(line.empty()) continue;
        // Comment Skip
        if(line[0] == '#') continue;

        // Tokenize the line
        int i = 0;
        std::istringstream stream(line);
        while(stream >> tokens[i]) i++;

        // Single token (Meaning it is a vertex)
        if(i == 1)
        {
            InsertVertex(tokens[0]);
        }
        // Exactly 5 tokens (Meaning it is an edge)
        else if(i == 5)
        {
            // Rename vars for readablity
            const std::string& vertexFromName = tokens[0];
            const std::string& vertexToName = tokens[1];
            const std::string& edgeName = tokens[2];
            float weight0 = static_cast<float>(std::atof(tokens[3].c_str()));
            float weight1 = static_cast<float>(std::atof(tokens[4].c_str()));
            AddEdge(edgeName, vertexFromName, vertexToName,
                    weight0, weight1);
        }
        else std::cerr << "Token Size Mismatch" << std::endl;
    }
}

void MultiGraph::PrintPath(const std::vector<int>& orderedVertexEdgeIndexList,
                           float heuristicWeight,
                           bool sameLine) const
{
    // ============================= //
    // This function is implemented  //
    // Do not edit this file !       //
    // ============================= //

    // Name is too long
    const std::vector<int>& ove = orderedVertexEdgeIndexList;
    // Invalid list
    // At least three items should be available
    if(ove.size() < 3) return;

    // Check vertex and an edge
    for(size_t i = 0; i < orderedVertexEdgeIndexList.size(); i += 2)
    {
        int vertexId = ove[i];
        if(vertexId >= static_cast<int>(vertexList.size()))
        {
            // Return if there is a bad vertex id
            std::cout << "VertexId " << vertexId
                      << " not found!" << std::endl;
            return;
        }


        const GraphVertex& vertex = vertexList[vertexId];
        std::cout << vertex.name;
        if(!sameLine) std::cout << "\n";
        // Only find and print the weight if next is available
        if(i == ove.size() - 1) break;
        int nextVertexId = ove[i + 2];
        if(nextVertexId >= static_cast<int>(vertexList.size()))
        {
            // Return if there is a bad vertex id
            std::cout << "VertexId " << vertexId
                    << " not found!" << std::endl;
            return;
        }

        // Find the edge between these two vertices
        int localEdgeId = ove[i + 1];
        if(localEdgeId >= static_cast<int>(vertex.edges.size()))
        {
            // Return if there is a bad vertex id
            std::cout << "EdgeId " << localEdgeId
                      << " not found in " << vertexId << "!" << std::endl;
            return;
        }

        const GraphEdge& edge = vertex.edges[localEdgeId];

        // Combine with heuristic (linear interpolation)
        float weight = Lerp(edge.weight[0], edge.weight[1],
                            heuristicWeight);

        std::cout << "-" << std::setfill('-')
                  << std::setw(4)
                  << weight << "->";
    }
    // Print endline on the last vertex if same line is set
    if(sameLine) std::cout << "\n";
    // Reset fill value because it "sticks" to the std out
    std::cout << std::setfill(' ');
    std::cout.flush();
}

void MultiGraph::PrintEntireGraph() const
{
    // ============================= //
    // This function is implemented  //
    // Do not edit this function !   //
    // ============================= //
    for(size_t i = 0; i < vertexList.size(); i++)
    {
        const GraphVertex& v = vertexList[i];
        std::cout << v.name << "\n";
        for(size_t j = 0; j < v.edges.size(); j++)
        {
            const GraphEdge& edge = v.edges[j];

            // List the all vertex names and weight
            std::cout << "    -"
                      << std::setfill('-')
                      << std::setw(4) << edge.weight[0]
                      << "-"
                      << std::setw(4) << edge.weight[1]
                      << "-> ";
            std::cout << vertexList[edge.endVertexIndex].name;
            std::cout << " (" << edge.name << ")" << "\n";
        }
    }
    // Reset fill value because it "sticks" to the std out
    std::cout << std::setfill(' ');
    std::cout.flush();
}

//=======================//
//          TODO         //
//=======================//
float MultiGraph::Lerp(float w0, float w1, float alpha)
{
    return (1.0f - alpha) * w0 + alpha * w1;
}

void MultiGraph::InsertVertex(const std::string& vertexName)
{
    for(int i = 0; i<vertexList.size(); i++){
        if(vertexList[i].name == vertexName) throw DuplicateVertexException(vertexName);
    }
    GraphVertex* add = new GraphVertex();
    add->name = vertexName;
    vertexList.push_back(*add);
    delete add;
}

void MultiGraph::RemoveVertex(const std::string& vertexName)
{
    bool in = false;
    int indx;
    for(int i = 0; i<vertexList.size(); i++){
        if(vertexList[i].name == vertexName){
            in = true;
            indx = i;
            break;
        } 
    }
    if(in){
        for(int i = 0; i<vertexList.size(); i++){
            for(int k = 0; k<vertexList[i].edges.size(); k++){
                if(vertexList[i].edges[k].endVertexIndex == indx)
                    vertexList[i].edges.erase(vertexList[i].edges.begin()+indx);
            }
        }
        vertexList.erase(vertexList.begin()+indx);
    }
    else throw VertexNotFoundException(vertexName);
}

void MultiGraph::AddEdge(const std::string& edgeName,
                         const std::string& vertexFromName,
                         const std::string& vertexToName,
                         float weight0, float weight1)
{
    bool from = false;
    bool to = false;
    int fromIndx;
    int toIndx;
    for(int i = 0; i<vertexList.size(); i++){
        if(vertexList[i].name == vertexFromName){
            from = true;
            fromIndx = i;
        }
        if(vertexList[i].name == vertexToName){
            to = true;
            toIndx = i;
        }
    }
    if(from && to){
        for(int i = 0; i<vertexList[fromIndx].edges.size(); i++){
            if(vertexList[fromIndx].edges[i].name == edgeName && vertexList[fromIndx].edges[i].endVertexIndex == toIndx) throw SameNamedEdgeException(edgeName,vertexFromName,vertexToName);
        }
        GraphEdge add;
        add.name = edgeName;
        add.weight[0] = weight0;
        add.weight[1] = weight1;
        add.endVertexIndex = toIndx;
        vertexList[fromIndx].edges.push_back(add);
        
    }
    else{
        if(from == false) throw VertexNotFoundException(vertexFromName);
        else if (to == false) throw VertexNotFoundException(vertexToName);
    }
    
}

void MultiGraph::RemoveEdge(const std::string& edgeName,
                            const std::string& vertexFromName,
                            const std::string& vertexToName)
{
    bool from = false;
    bool to = false;
    int fromIndx;
    int toIndx;
    for(int i = 0; i<vertexList.size(); i++){
        if(vertexList[i].name == vertexFromName){
            from = true;
            fromIndx = i;
        }
        else if(vertexList[i].name == vertexToName){
            to = true;
            toIndx = i;
        }
    }
    if(from && to){
        bool edg = false;
        int edgIndx;
        for(int i = 0; i<vertexList[fromIndx].edges.size(); i++){
            if(vertexList[fromIndx].edges[i].name == edgeName){
                edg = true;
                edgIndx = i;
                break;
            } 
            
        }
        if(!edg) throw EdgeNotFoundException(vertexFromName,edgeName);
        vertexList[fromIndx].edges.erase(vertexList[fromIndx].edges.begin() + edgIndx);
        
        
    }
    else{
        if(from == false) throw VertexNotFoundException(vertexFromName);
        else if (to == false) throw VertexNotFoundException(vertexToName);
    }
}

bool MultiGraph::HeuristicShortestPath(std::vector<int>& orderedVertexEdgeIndexList,
                                       const std::string& vertexNameFrom,
                                       const std::string& vertexNameTo,
                                       float heuristicWeight) const
{
    std::vector<bool> visited(vertexList.size(),false);
    std::vector<float> weight(vertexList.size(),999999999999.0);
    std::vector<int> prev(vertexList.size(),-1);
    std::vector<int> names(vertexList.size(),-1); 
    
    bool from = false;
    bool to = false;
    int fromIndx;
    int toIndx;
    for(int i = 0; i<vertexList.size(); i++){
        if(vertexList[i].name == vertexNameFrom){
            from = true;
            fromIndx = i;
        }
        else if(vertexList[i].name == vertexNameTo){
            to = true;
            toIndx = i;
        }
    }
    MinPairHeap<int,std::vector<GraphEdge>> que;
    if(from && to){
        weight[fromIndx] = 0;
        que.push({fromIndx,vertexList[fromIndx].edges});
        while(!que.empty()){
            Pair<int,std::vector<GraphEdge>> frontP = que.top();
            que.pop();
            if(visited[frontP.key] == false){
                visited[frontP.key] = true;
                for(int i = 0; i< frontP.value.size(); i++){
                    float weig = weight[frontP.key] + Lerp(frontP.value[i].weight[0],frontP.value[i].weight[1],heuristicWeight);
                    if(weig < weight[frontP.value[i].endVertexIndex]){  
                        weight[frontP.value[i].endVertexIndex] = weig;
                        names[frontP.value[i].endVertexIndex] = i;
                        prev[frontP.value[i].endVertexIndex] = frontP.key;
                    }
                    que.push({frontP.value[i].endVertexIndex,vertexList[frontP.value[i].endVertexIndex].edges});
                }
            }
        }
        int currIndx = toIndx;
        while(currIndx != fromIndx){
            orderedVertexEdgeIndexList.push_back(currIndx);
            orderedVertexEdgeIndexList.push_back(names[currIndx]);
            currIndx = prev[currIndx];
        }
        orderedVertexEdgeIndexList.push_back(fromIndx);
        for(int i = 0, j = orderedVertexEdgeIndexList.size()-1; i<orderedVertexEdgeIndexList.size()/2 ; i++,j--){
            int tmp = orderedVertexEdgeIndexList[i];
            orderedVertexEdgeIndexList[i] = orderedVertexEdgeIndexList[j];
            orderedVertexEdgeIndexList[j] = tmp;
        }
        if(currIndx == fromIndx) return true;
        else return false;
    }
    else{
        if(from == false) throw VertexNotFoundException(vertexNameFrom);
        else if (to == false) throw VertexNotFoundException(vertexNameTo);
    }
    return false;
}

bool MultiGraph::FilteredShortestPath(std::vector<int>& orderedVertexEdgeIndexList,
                                      const std::string& vertexNameFrom,
                                      const std::string& vertexNameTo,
                                      float heuristicWeight,
                                      const std::vector<std::string>& edgeNames) const
{
    std::vector<bool> visited(vertexList.size(),false);
    std::vector<float> weight(vertexList.size(),999999999999.0);
    std::vector<int> prev(vertexList.size(),-1);
    std::vector<int> names(vertexList.size(),-1); 
    
    bool from = false;
    bool to = false;
    int fromIndx;
    int toIndx;
    for(int i = 0; i<vertexList.size(); i++){
        if(vertexList[i].name == vertexNameFrom){
            from = true;
            fromIndx = i;
        }
        else if(vertexList[i].name == vertexNameTo){
            to = true;
            toIndx = i;
        }
    }
    MinPairHeap<int,std::vector<GraphEdge>> que;
    if(from && to){
        weight[fromIndx] = 0;
        que.push({fromIndx,vertexList[fromIndx].edges});
        while(!que.empty()){
            Pair<int,std::vector<GraphEdge>> frontP = que.top();
            que.pop();
            if(visited[frontP.key] == false){
                visited[frontP.key] = true;
                for(int i = 0; i< frontP.value.size(); i++){
                    float weig = weight[frontP.key] + Lerp(frontP.value[i].weight[0],frontP.value[i].weight[1],heuristicWeight);
                    if(weig < weight[frontP.value[i].endVertexIndex]){  
                        bool possible = true;
                        for (int j = 0; j < edgeNames.size(); j++){
                            if(frontP.value[i].name == edgeNames[j]){
                                possible = false;
                            }
                        }
                        if(possible){
                            weight[frontP.value[i].endVertexIndex] = weig;
                            names[frontP.value[i].endVertexIndex] = i;
                            prev[frontP.value[i].endVertexIndex] = frontP.key;
                        }
                    }
                    que.push({frontP.value[i].endVertexIndex,vertexList[frontP.value[i].endVertexIndex].edges});
                }
            }
        }
        int currIndx = toIndx;
        while(currIndx != fromIndx){
            if(names[currIndx] == -1 ){
                return false;
            }
            orderedVertexEdgeIndexList.push_back(currIndx);
            orderedVertexEdgeIndexList.push_back(names[currIndx]);
            currIndx = prev[currIndx];
        }
        orderedVertexEdgeIndexList.push_back(fromIndx);
        for(int i = 0, j = orderedVertexEdgeIndexList.size()-1; i<orderedVertexEdgeIndexList.size()/2 ; i++,j--){
            int tmp = orderedVertexEdgeIndexList[i];
            orderedVertexEdgeIndexList[i] = orderedVertexEdgeIndexList[j];
            orderedVertexEdgeIndexList[j] = tmp;
        }
        if(currIndx == fromIndx) return true;
        else return false;
    }
    else{
        if(from == false) throw VertexNotFoundException(vertexNameFrom);
        else if (to == false) throw VertexNotFoundException(vertexNameTo);
    }
    return false;
}

int MultiGraph::BiDirectionalEdgeCount() const
{
    int count = 0;
    std::vector<int> endP;
    std::vector<std::string> names;
    for(int i = 0; i < vertexList.size() ; i++){
        for(int j = 0; j< vertexList[i].edges.size() ; j++){    
            endP.push_back( vertexList[i].edges[j].endVertexIndex );
            names.push_back( vertexList[i].edges[j].name );
        }
        for(int j = 0; j < endP.size(); j++){
            for(int k = 0; k< vertexList[endP[j]].edges.size(); k++){    
                if( vertexList[endP[j]].edges[k].endVertexIndex == i && vertexList[endP[j]].edges[k].name == names[j]) count++;
            }
        }
        endP.clear();
        names.clear();
    } 
    
    return count/2;
}

int MultiGraph::MaxDepthViaEdgeName(const std::string& vertexName,
                                    const std::string& edgeName) const
{
    std::vector<bool> visited(vertexList.size(),false);
    std::vector<int> count (vertexList.size(), 0);

    bool vrtx = false;
    int vrtxIndx;
    int max_depth = 0;
    for ( int i = 0; i<vertexList.size(); i++){
        if(vertexList[i].name == vertexName){
            vrtx = true;
            vrtxIndx = i;
            break;
        }
    }
    if(vrtx){
        MinPairHeap<int,std::vector<GraphEdge>> que;
        que.push({ vrtxIndx , vertexList[vrtxIndx].edges });
        while(!que.empty()){
            Pair<int,std::vector<GraphEdge>> frontP = que.top();
            que.pop();
            if(visited[frontP.key] == false){
                visited[frontP.key] = true;
                for(int i = 0; i < frontP.value.size() ; i++){
                    if(frontP.value[i].name == edgeName){
                        if(count[frontP.value[i].endVertexIndex] == 0 || count[frontP.value[i].endVertexIndex] > count[frontP.key] + 1){
                            count[frontP.value[i].endVertexIndex] = count[frontP.key] + 1;
                        }
                        que.push({frontP.value[i].endVertexIndex, vertexList[frontP.value[i].endVertexIndex].edges });
                    }
                }
            }
        }
          
    
        int max = count[0];
        
        for(int i = 1; i<count.size(); i++){
            if(count[i] > max){
                max = count[i];
            }
        }
        return max;
    }
    else throw VertexNotFoundException(vertexName);
}

bool MultiGraph::findEdgeWeight(const std::string& vertexFromName,
                                const std::string& vertexToName,
                                const std::string& edgeName,
                                std::vector<float>& weights)
{
    bool from = false;
    bool to = false;
    int fromIndx;
    int toIndx;
    for(int i = 0; i<vertexList.size(); i++){
        if(vertexList[i].name == vertexFromName){
            from = true;
            fromIndx = i;
        }
        else if(vertexList[i].name == vertexToName){
            to = true;
            toIndx = i;
        }
    }
    if(from && to){
        for(int i = 0; i<vertexList[fromIndx].edges.size(); i++){
            if(vertexList[fromIndx].edges[i].name == edgeName){
                weights[0] = vertexList[fromIndx].edges[i].weight[0];
                weights[1] = vertexList[fromIndx].edges[i].weight[1];
                return true;
            }
        }
        return false;
        
    }
    else return false;
}

int MultiGraph::findIndex(const std::string& vertexFromName)const
{
    for(int i = 0; i<vertexList.size() ; i++){
        if(vertexList[i].name == vertexFromName) return i;
    }
    return -1;
}













